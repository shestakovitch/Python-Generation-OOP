"""Классы Card и Deck
1. Реализуйте класс Card, описывающий игральную карту. При создании экземпляра класс должен принимать два аргумента в следующем порядке:

suit — масть игральной карты, представленная одним из следующих символов:
♣, ♢, ♡, ♠
rank — ранг игральной карты, представленный одним из следующих символов или парой символов:
2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A
Экземпляр класса Card должен иметь следующее неформальное строковое представление:

<масть игральной карты><ранг игральной карты>
2. Также реализуйте класс данных Deck, описывающий классическую колоду из 52 игральных карт. Карты в колоде должны быть
расположены сперва в порядке возрастания мастей, а затем — в порядке возрастания рангов. При создании экземпляра класс
не должен принимать никаких аргументов.

Класс Deck должен иметь два метода экземпляра:

shuffle() — метод, перемешивающий все карты в колоде. Перемешивать колоду можно только в том случае, если в колоде на
данный момент находятся все 52 карты. Если в колоде меньше 52 карт, должно быть возбуждено исключение ValueError с
текстом:
Перемешивать можно только полную колоду
deal() — метод, удаляющий из колоды последнюю карту и возвращающий ее. Если колода пуста, должно быть возбуждено
исключение ValueError с текстом:
Все карты разыграны
Экземпляр класса Deck должен иметь следующее неформальное строковое представление:

Карт в колоде: <текущее количество карт в колоде>
Примечание 1. Порядок старшинства карточных рангов от младшего к старшему:

2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A
Порядок старшинства карточных мастей от младшего к старшему:

♣, ♢, ♡, ♠
Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованные классы
используются только с корректными данными.

Примечание 3. Никаких ограничений касательно реализаций классов нет, они могут быть произвольными."""


from random import shuffle


class Card:
    def __init__(self, suit, rank):
        self.suit = suit
        self.rank = rank

    def __repr__(self):
        return f'{self.suit}{self.rank}'


class Deck:
    __deck = [Card(j, i) for j in '♣♢♡♠' for i in (*range(2, 11), *'JQKA')]

    def shuffle(self):
        if len(self.__deck) != 52:
            raise ValueError('Перемешивать можно только полную колоду')
        shuffle(self.__deck)
        return self.__deck

    def deal(self):
        if len(self.__deck) == 0:
            raise ValueError('Все карты разыграны')
        return self.__deck.pop()

    def __repr__(self):
        return f'Карт в колоде: {len(self.__deck)}'


# Sample Input 1:
#
# print(Card('♣', '4'))
# print(Card('♡', 'A'))
# print(Card('♢', '10'))
# Sample
# Output
# 1:
#
# ♣4
# ♡A
# ♢10
# Sample Input 2:
#
# deck = Deck()
#
# print(deck)
# print(deck.deal())
# print(deck.deal())
# print(deck.deal())
# print(type(deck.deal()))
# print(deck)
# Sample Output 2:
#
# Карт в колоде: 52
# ♠A
# ♠K
# ♠Q
# <class '__main__.Card'>
# Карт в колоде: 48

# Sample Input 3:
#
# deck = Deck()
#
# for _ in range(52):
#     deck.deal()
#
# try:
#     deck.deal()
# except ValueError as error:
#     print(error)
# Sample Output 3:
#
# Все карты разыграны
# Sample Input 4:
#
# deck = Deck()
#
# deck.deal()
#
# try:
#     deck.shuffle()
# except ValueError as error:
#     print(error)
# Sample Output 4:
#
# Перемешивать можно только полную колоду